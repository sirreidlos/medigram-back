use axum::Json;
use axum::http::StatusCode;
use axum::response::IntoResponse;
use axum::response::Response;

use base64::Engine;
use ed25519_compact::{PublicKey, Signature};
use serde::de::Error;
use serde::{Deserialize, Serialize};
use serde_json_canonicalizer::to_string;
use uuid::Uuid;

/// Since NIK only consists of 16 digits, should it be higher than this number
/// (10^17-1), it means that it's an invalid NIK.
pub const NIK_UPPERBOUND: i64 = 9_999_999_999_999_999;

/// Since NIK only consists of 16 digits, should it be lower than this number
/// (10^15), it means that it's an invalid NIK.
pub const NIK_LOWERBOUND: i64 = 1_000_000_000_000_000;

// #[derive(Debug, Serialize, Deserialize, Clone, Copy)]
/// Wrapper struct for `Nomor Induk Kependudukan` containing exactly 16
/// digits.
// #[derive(Hash, Eq, PartialEq)]
pub type Nik = i64;
pub type Nonce = [u8; 16];
// impl Display for Nik {
//     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
//         self.0.fmt(f)
//     }
// }

// impl TryFrom<u64> for Nik {
//     // there's only two possible ways for it to err
//     // we can just throw a unit type for the error
//     type Error = ();

//     fn try_from(value: u64) -> Result<Self, Self::Error> {
//         if !(NIK_LOWERBOUND..=NIK_UPPERBOUND).contains(&value) {
//             return Err(());
//         }

//         Ok(Self(value))
//     }
// }

// impl TryFrom<BigDecimal> for Nik {
//     type Error = ();

//     fn try_from(value: BigDecimal) -> Result<Self, Self::Error> {
//         match value.to_u64() {
//             Some(v) => Ok(Self(v)),
//             None => Err(()),
//         }
//     }
// }

/// The consent.
///
/// What this essentially contains is the signer's ID and a nonce generated by
/// the server. The nonce will then be stored in a timed cache for a certain
/// amount of time, in which it will be kept until either it expires or a client
/// sent a message with a consent that uses the nonce.
#[derive(Debug, Serialize, Deserialize)]
pub struct Consent {
    pub signer_device_id: Uuid,
    pub nonce: Nonce,

    #[serde(
        serialize_with = "serialize_signature",
        deserialize_with = "deserialize_signature"
    )]
    pub signature: Signature,
}

impl Consent {
    /// Verify that the signer did actually sign this.
    ///
    /// Requires the other party's `PublicKey`.
    pub fn verify(&self, pk: &PublicKey) -> bool {
        // let msg = format!("{}{}", self.signer, self.nonce);
        let message = to_string(&(self.signer_device_id, self.nonce));

        match message {
            Ok(msg) => pk.verify(msg, &self.signature).is_ok(),

            Err(_) => false,
        }
    }
}

pub enum ConsentError {
    NonConsent,
    NonceGone,
    DeviceNotFound,
    UserDeviceMismatch,
    KeyExpired,
    NotLicensed,
}

impl IntoResponse for ConsentError {
    fn into_response(self) -> Response {
        let (status, error_message) = match self {
            ConsentError::NonConsent => {
                (StatusCode::UNAUTHORIZED, "User did not consent")
            }
            ConsentError::NonceGone => {
                (StatusCode::UNAUTHORIZED, "Nonce has been used or expired")
            }
            ConsentError::DeviceNotFound => {
                (StatusCode::NOT_FOUND, "Device not found")
            }
            ConsentError::UserDeviceMismatch => {
                (StatusCode::BAD_REQUEST, "User does not own this device")
            }
            ConsentError::KeyExpired => {
                (StatusCode::GONE, "Consesnt has expired")
            }
            ConsentError::NotLicensed => {
                (StatusCode::FORBIDDEN, "You are not a licensed practitioner")
            }
        };

        let body = Json(serde_json::json!({
            "error": error_message,
        }));

        (status, body).into_response()
    }
}

// fn get_consent(request: &axum::extract::Request) -> Result<Consent, AppError>
// {     // get the json body's 'consent' object and deserialize it into Consent
//     // struct
//     todo!()
// }

// pub async fn consent_middleware(
//     State(state): State<AppState>,
//     headers: axum::http::HeaderMap,
//     request: axum::extract::Request,
//     next: axum::middleware::Next,
// ) -> Result<axum::response::Response, AppError> {
//     // parse the request body into a struct for
//     //

//     let consent: Consent = todo!();
//     let device_id = consent.signer_device_id;
//     let key_info = retrieve_public_key(device_id, &state.db_pool).await?;
//     let public_key =
//         PublicKey::from_pem(&key_info.public_key_pem).map_err(|e| {
//             error!("error while converting pem to pk: {:?}", e);
//             AppError::InternalError
//         })?;
//     let is_valid = get_consent(&request)?;

//     if consent.verify(&public_key) {
//         let response = next.run(request).await;
//         Ok(response)
//     } else {
//         Err(ConsentError::NonConsent.into())
//     }
// }

fn serialize_signature<S>(
    signature: &ed25519_compact::Signature,
    serializer: S,
) -> Result<S::Ok, S::Error>
where
    S: serde::Serializer,
{
    let encoded =
        base64::engine::general_purpose::STANDARD.encode(signature.as_ref());
    serializer.serialize_str(&encoded)
}

fn deserialize_signature<'de, D>(
    deserializer: D,
) -> Result<ed25519_compact::Signature, D::Error>
where
    D: serde::Deserializer<'de>,
{
    let encoded: String = Deserialize::deserialize(deserializer)?;
    let decoded = base64::engine::general_purpose::STANDARD
        .decode(&encoded)
        .map_err(D::Error::custom)?;

    ed25519_compact::Signature::from_slice(&decoded).map_err(D::Error::custom)
}

#[derive(Debug, Serialize, Deserialize)]
struct ConsultationData {
    diagnoses: String,
    symptoms: String,
    prescription: String,
    regimen: u8,
    additional_description: String,
    patient_consent: Consent,
}

#[derive(Debug, Serialize, Deserialize)]
struct PrescriptionData {
    doctor_consent: Consent,
}

#[cfg(test)]
mod test {
    use super::*;
    use ed25519_compact::KeyPair;
    use serde_json_canonicalizer::to_string;
    use uuid::Uuid;

    #[test]
    fn test_consent_serialization() {
        let keypair = KeyPair::generate();
        let nonce = [42u8; 16];
        let message = to_string(&(Uuid::nil(), nonce)).unwrap();
        let signature = keypair.sk.sign(message, None);

        let consent = Consent {
            signer_device_id: Uuid::nil(),
            nonce,
            signature,
        };

        let serialized =
            serde_json::to_string(&consent).expect("Serialization failed");
        let deserialized: Consent =
            serde_json::from_str(&serialized).expect("Deserialization failed");

        assert_eq!(consent.signer_device_id, deserialized.signer_device_id);
        assert_eq!(consent.nonce, deserialized.nonce);
        assert_eq!(consent.signature.as_ref(), deserialized.signature.as_ref());
    }

    #[test]
    fn test_consent_verification() {
        let keypair = KeyPair::generate();
        let nonce = [99u8; 16];
        let message = to_string(&(Uuid::nil(), nonce)).unwrap();
        let signature = keypair.sk.sign(message, None);

        let consent = Consent {
            signer_device_id: Uuid::nil(),
            nonce,
            signature,
        };

        assert!(consent.verify(&keypair.pk));
    }

    #[test]
    fn test_consent_verification_failure() {
        let keypair = KeyPair::generate();
        let another_keypair = KeyPair::generate();
        let nonce = [1u8; 16];
        let message = to_string(&(Uuid::nil(), nonce)).unwrap();
        let signature = keypair.sk.sign(message, None);

        let consent = Consent {
            signer_device_id: Uuid::nil(),
            nonce,
            signature,
        };

        assert!(!consent.verify(&another_keypair.pk));
    }
}
