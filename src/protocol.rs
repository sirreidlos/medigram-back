use std::fmt::Display;

use base64::Engine;
use ed25519_compact::{PublicKey, Signature};
use serde::de::Error;
use serde::{Deserialize, Serialize};
use serde_json_canonicalizer::to_string;
use uuid::Uuid;

/// Since NIK only consists of 16 digits, should it be higher than this number
/// (10^17-1), it means that it's an invalid NIK.
const NIK_UPPERBOUND: u64 = 9_999_999_999_999_999;

/// Since NIK only consists of 16 digits, should it be lower than this number
/// (10^15), it means that it's an invalid NIK.
const NIK_LOWERBOUND: u64 = 1_000_000_000_000_000;

#[derive(Debug, Serialize, Deserialize, Clone, Copy)]
/// Wrapper struct for `Nomor Induk Kependudukan` containing exactly 16
/// digits.
struct Nik(u64);

impl Display for Nik {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        self.0.fmt(f)
    }
}

impl TryFrom<u64> for Nik {
    // there's only two possible ways for it to err
    // we can just throw a unit type for the error
    type Error = ();

    fn try_from(value: u64) -> Result<Self, Self::Error> {
        if !(NIK_LOWERBOUND..=NIK_UPPERBOUND).contains(&value) {
            return Err(());
        }

        Ok(Self(value))
    }
}

/// The consent.
///
/// What this essentially contains is the signer's ID and a nonce generated by
/// the server. The nonce will then be stored in a timed cache for a certain
/// amount of time, in which it will be kept until either it expires or a client
/// sent a message with a consent that uses the nonce.
#[derive(Debug, Serialize, Deserialize)]
struct Consent {
    signer_device_id: Uuid,
    nonce: [u8; 16],

    #[serde(
        serialize_with = "serialize_signature",
        deserialize_with = "deserialize_signature"
    )]
    signature: Signature,
}

impl Consent {
    /// Verify that the signer did actually sign this.
    ///
    /// Requires the other party's `PublicKey`.
    pub fn verify(&self, pk: &PublicKey) -> bool {
        // let msg = format!("{}{}", self.signer, self.nonce);
        let message = to_string(&(self.signer_device_id, self.nonce));

        match message {
            Ok(msg) => pk.verify(msg, &self.signature).is_ok(),

            Err(_) => false,
        }
    }
}

fn serialize_signature<S>(
    signature: &ed25519_compact::Signature,
    serializer: S,
) -> Result<S::Ok, S::Error>
where
    S: serde::Serializer,
{
    let encoded =
        base64::engine::general_purpose::STANDARD.encode(signature.as_ref());
    serializer.serialize_str(&encoded)
}

fn deserialize_signature<'de, D>(
    deserializer: D,
) -> Result<ed25519_compact::Signature, D::Error>
where
    D: serde::Deserializer<'de>,
{
    let encoded: String = Deserialize::deserialize(deserializer)?;
    let decoded = base64::engine::general_purpose::STANDARD
        .decode(&encoded)
        .map_err(D::Error::custom)?;

    ed25519_compact::Signature::from_slice(&decoded).map_err(D::Error::custom)
}

#[derive(Debug, Serialize, Deserialize)]
struct ConsultationData {
    diagnoses: String,
    symptoms: String,
    prescription: String,
    regimen: u8,
    additional_description: String,
    patient_consent: Consent,
}

#[derive(Debug, Serialize, Deserialize)]
struct PrescriptionData {
    doctor_consent: Consent,
}

#[cfg(test)]
mod test {
    use super::*;
    use ed25519_compact::KeyPair;
    use serde_json_canonicalizer::to_string;
    use uuid::Uuid;

    #[test]
    fn test_consent_serialization() {
        let keypair = KeyPair::generate();
        let nonce = [42u8; 16];
        let message = to_string(&(Uuid::nil(), nonce)).unwrap();
        let signature = keypair.sk.sign(message, None);

        let consent = Consent {
            signer_device_id: Uuid::nil(),
            nonce,
            signature,
        };

        let serialized =
            serde_json::to_string(&consent).expect("Serialization failed");
        let deserialized: Consent =
            serde_json::from_str(&serialized).expect("Deserialization failed");

        assert_eq!(consent.signer_device_id, deserialized.signer_device_id);
        assert_eq!(consent.nonce, deserialized.nonce);
        assert_eq!(consent.signature.as_ref(), deserialized.signature.as_ref());
    }

    #[test]
    fn test_consent_verification() {
        let keypair = KeyPair::generate();
        let nonce = [99u8; 16];
        let message = to_string(&(Uuid::nil(), nonce)).unwrap();
        let signature = keypair.sk.sign(message, None);

        let consent = Consent {
            signer_device_id: Uuid::nil(),
            nonce,
            signature,
        };

        assert!(consent.verify(&keypair.pk));
    }

    #[test]
    fn test_consent_verification_failure() {
        let keypair = KeyPair::generate();
        let another_keypair = KeyPair::generate();
        let nonce = [1u8; 16];
        let message = to_string(&(Uuid::nil(), nonce)).unwrap();
        let signature = keypair.sk.sign(message, None);

        let consent = Consent {
            signer_device_id: Uuid::nil(),
            nonce,
            signature,
        };

        assert!(!consent.verify(&another_keypair.pk));
    }
}
